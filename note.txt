
设定一: 基于idea+window平台下快速开发和代码管理
设定二: 所有的进程字典和进程消息都要用宏包装, 弃用弃用弃用
设定三: 各种名字必须带有对应功能(模块)的标识前序, module1_xxx, module2_xxx
设定四: 大部分使用半自动思路, 提高该项目开发效率, 20%时间做80%事情
设定五: 使用throw返回错误码
设定六: 模块缩写映射文件(module_sname.txt), 缩写对应的英文和中文
    缩写不可重复, 文件名不能用缩写
设定七: 模块内record使用缩写, 在定义的地方写缩写对应的英文和中文
设定八: 进程字典tag使用pb_前序, 进程消息tag使用pm_前序, 如pb_example, {pb_example, 1, 3}
    ets用ets_前序, 这类原子都使用宏包装-defined(PD_EXAMPLE(1,2), {pb_example, 1, 3})
    或 -defined(PD_EXAMPLE, pb_example)
设定九: 同一份数据同一时间只能由一个进程更新
设定十: 一次消息内提供一定的回滚机制, 时间矫正
    对应操作commit immediately, hold change, set change
    cast, info, send msg to client, virture, process dict
    时间矫正通过包装消息({时间戳, 消息})和进程字典实现

2020/05/27
文件结构参照 MongooseIM

cmd
    SET ERL_FLAGS=-args_file config/vm.args -config config/sys.config
    rebar3 shell
ps
    $Env:ERL_FLAGS=" -args_file config/vm.args -config config/sys.config"
    rebar3 shell
linux
    ERL_FLAGS=" -args_file config/vm.args -config config/sys.config" rebar3 shell

exia
    实现一个record数据集合(可以是任意存储结构)的额外索引
    不影响原有存储结构, 原有结构仅需要提供is_exist的实现方法
    实现dict和tree索引

2020/05/30
增加uitl模块
继续实现exia
    索引结构 = struct(索引数据)
    索引数据 = private_key + 索引key + record
    遍历支持break操作, ?UTIL_FOLD_BREAK
    dict索引: 简单kv存储 叶节点{key, [record]}
        简单效率也会高一点
        经常使用范围搜索或者跟'排序有关的操作', 使用tree会更好, 因为dict本身就是乱序的
    tree索引: 类似b树 所有叶节点从小到大排序, 有左前序特性, 索引自动分层
        例如{type, subtype, subsubtype,,}, 且索引中每个值有上下限
        可以通过范围搜索方便的遍历所有type=1,subtype=2的数据
        即 {1, 2, subsubmin,,} =< key =< {1,2, subsubmax,,}

2020/5/31
exia tree
    删除元素导致合并, 父节点与相邻节点尝试合并或者平衡数量
    key从小到大排序, key相等时element乱序
    当 key_exist >= key_new 插入节点
    key值占用 ?EXIA_TREE_KEY 用于优化范围搜索

2020/6/1
virture
    实现基于ets的数据缓存, 数据库用mysql
    算是为玩家进程服务
    数据量超大的公共进程频率和量级都不一样不太适合
    只适存在唯一键的数据, 跟应数据库一一对应
    不过很少没有唯一键的情况就是
    一般来说数据会有3份
    process dict + ets + db
    process <=> ets
        进程需要拿到锁(悲观锁)才能更新数据
        进程读取数据后会做本地缓存
        进程做数据差异比较, 然后同步ets
        其他进程可以通关ets脏读
    ets <=> db
        首次读取时从数据库拿
        定时落地 + 手动强制落地
    ets存储结构为单层哈希
    监督树开进程, 在代码里面传参数

2020/6/6
重新设计virture
    数据与数据库(mysql)一一映射
    record名字 = 表名 = ets后缀名(ets_table_name)
    record字段名 = 数据库字段名
    recod可以存在非数据库字段, 需要自行初始化
    动态生成数据库语句
    数据缓存到进程, 使用dict或者list存储
    支持回滚
    改变时同步到ets
    仅支持存在唯一主键的数据
    实际上99%的表都是有主键的
实现本地节点锁
补上一些常用宏

2020/6/14
不使用exia模块了, 直接用对应的结构
增加performan文件夹, 放性能测试代码

2020/6/29
后续代码按照 简单原型+特定场景=特化demo 写
原型代码后序为 _origin, 里面应大量注释如何diy

2020/7/14
整理一下:
    数据结构实现一个原型, 在文件头写上优化注释
    减少在数据结构上花费的时间, 80%时间做20%的提升!!!
    下一步mysql替换成MongoDB
    接入gpb, 让服务器先起来再说
    配置表, erl客户端, 性能测试

2020/7/21
re:run(B, "message\s*([A-z0-9_]*)\s*{//\s*([0-9]*)",[global, multiline, {capture,[1,2], binary}]).